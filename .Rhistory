geom_point(data = df.3, aes(x = m.mean, y = sig), col = "blue") +
ylim(0,2.25) + xlim(0.95,1.05)
q.3 <- copy(df.3)
q.3$hj <- HJ.bound(R,Sig,q.3$m.mean)
q.3$ok <- (q.3$sig > q.3$hj)
q.3 <- subset(q.3, ok == TRUE)
q.3 <- q.3[,3:4]
kable(q.3, row.names = FALSE, align = c('l','l'),
caption = "EZ-Paramter Values consistent with Data")
plot.zoo(s.seq)
length(s.seq)
length(cc)
plot(cc)
length(c)
cute.s <- xts(s.seq, order.by = index(c))
plot(cute.s)
cute.s <- xts(s.seq, order.by = index(c))
plot(cute.s)
cute.s <- xts(s.seq, order.by = index(c))
plot(cute.s, main = expression(S[t]))
cute.s.g <- xts(s.g, order.by = index(c)[2:length(index(c))])
plot(cute.s.g, main = expression(S[t]/S[t-1]))
q.3
q.3 <- copy(df.3)
q.3$hj <- HJ.bound(R,Sig,q.3$m.mean)
q.3$ok <- (q.3$sig > q.3$hj)
q.3 <- subset(q.3, ok == TRUE)
q.3
q.3 <- q.3[,c(1,3:4)]
q.3
q.3 <- copy(df.3)
q.3$hj <- HJ.bound(R,Sig,q.3$m.mean)
q.3$ok <- (q.3$sig > q.3$hj)
q.3 <- subset(q.3, ok == TRUE)
q.3 <- q.3[,c(1,3:4)]
q.3$m.mean <- 1 / q.3$m.mean - 1
names(q.3)[1] <- "r"
kable(q.3, row.names = FALSE, align = c('l','l'),
caption = "CC-Paramter Values consistent with Data")
q.3 <- copy(df.3)
q.3$hj <- HJ.bound(R,Sig,q.3$m.mean)
q.3$ok <- (q.3$sig > q.3$hj)
q.3 <- subset(q.3, ok == TRUE)
q.3 <- q.3[,c(1,3:4)]
q.3$m.mean <- (1 / q.3$m.mean - 1) * 100
names(q.3)[1] <- "r"
kable(q.3, row.names = FALSE, align = c('l','l'),
caption = "CC-Paramter Values consistent with Data", digits = 2)
q.3 <- copy(df.3)
q.3$hj <- HJ.bound(R,Sig,q.3$m.mean)
q.3$ok <- (q.3$sig > q.3$hj)
q.3 <- subset(q.3, ok == TRUE)
q.3 <- q.3[,c(1,3:4)]
q.3$m.mean <- (1 / q.3$m.mean - 1) * 100
names(q.3)[1] <- "r(percent)"
kable(q.3, row.names = FALSE, align = c('l','l'),
caption = "CC-Paramter Values consistent with Data", digits = 2)
dc.2 <- dc[index(dc) >= as.Date("2001-01-01")]
delta = 0.98
ccapm.m <- function(dc,delta,gamma){
m <- delta * dc^(-gamma)
temp <- numeric()
temp[1] <- mean(m)
temp[2] <- sd(m)
return(temp)
}
gamma.seq <- seq(1,40,by = 1)
mm.1 <- sapply(gamma.seq, ccapm.m, dc = dc + 1, delta = delta)
#this is the data frame for ccapm
df.1 <- data.frame(m.mean = mm.1[1,],
sig = mm.1[2,],
gamma = gamma.seq)
ggplot() + geom_line(data = df.hj, aes(x = m.mean, y = sig)) +
geom_text(data = df.1, aes(x = m.mean, y = sig, label = gamma), size = 3.75) +
xlim(0.96,1.025) + ylim(0,1.5) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
dc.2 <- dc[index(dc) >= as.Date("2001-01-01")]
delta = 0.98
ccapm.m <- function(dc,delta,gamma){
m <- delta * dc^(-gamma)
temp <- numeric()
temp[1] <- mean(m)
temp[2] <- sd(m)
return(temp)
}
gamma.seq <- seq(1,40,by = 1)
mm.1 <- sapply(gamma.seq, ccapm.m, dc = dc + 1, delta = delta)
#this is the data frame for ccapm
df.1 <- data.frame(m.mean = mm.1[1,],
sig = mm.1[2,],
gamma = gamma.seq)
ggplot() + geom_line(data = df.hj, aes(x = m.mean, y = sig)) +
geom_text(data = df.1, aes(x = m.mean, y = sig, label = gamma), size = 3.75) +
xlim(0.96,1.025) + ylim(0,1.05) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
ggplot() + geom_line(data = df.hj.2, aes(x = m.mean, y = sig)) +
geom_point(data = df.2, aes(x = m.mean, y = sig), col = "blue") +
ylim(0,2.25) + xlim(0.95,1.05) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
## H-J Bound
data.r <- data[,1:2] + 1
R <- as.matrix(colMeans(data.r))
Sig <- cov(data.r)
HJ.bound <- function(R,Sig,v.seq){
b.seq <- rep(0,length(v.seq))
count <- 0
for (v in v.seq) {
count <- count + 1
b.seq[count] <- sqrt(t(1 - v * R) %*% solve(Sig) %*% (1 - v * R)) / v
}
return(b.seq)
}
v.seq <- seq(0.8,1.2,by = 0.0001)
t <- HJ.bound(R,Sig,v.seq)
#plot the HJ Bound
#plot(v.seq,v.seq * t, type = 'l')
#Use data after 2000
cut.date <- as.Date("2000-01-01")
data <- cbind(data,index(dc))
data.2 <- subset(data, index(dc) >= cut.date)
data.2 <- data.2[,1:2]
R.2 <- as.matrix(colMeans(data.2)) + 1
Sig.2 <- cov(data.2)
t.2 <- HJ.bound(R.2,Sig.2,v.seq)
#plot(v.seq,v.seq * t.2, type = 'l')
plot(v.seq, v.seq * t, col = "red", type = 'l',
xlab = expression(bar(M)), ylab = expression(sigma(M)),
main = "Hansen-Jagannathan Bound", lty = 5,
xlim= c(0.95,1.05))
lines(v.seq,v.seq * t.2, type = 'l', lwd = 3)
df.hj <- data.frame(m.mean = v.seq, sig = v.seq * t)
df.hj.2 <- data.frame(m.mean = v.seq, sig = v.seq * t.2)
## H-J Bound
data.r <- data[,1:2] + 1
R <- as.matrix(colMeans(data.r))
Sig <- cov(data.r)
HJ.bound <- function(R,Sig,v.seq){
b.seq <- rep(0,length(v.seq))
count <- 0
for (v in v.seq) {
count <- count + 1
b.seq[count] <- sqrt(t(1 - v * R) %*% solve(Sig) %*% (1 - v * R)) / v
}
return(b.seq)
}
v.seq <- seq(0.8,1.2,by = 0.0001)
t <- HJ.bound(R,Sig,v.seq)
#plot the HJ Bound
#plot(v.seq,v.seq * t, type = 'l')
#Use data after 2000
cut.date <- as.Date("2000-01-01")
data <- cbind(data,index(dc))
data.2 <- subset(data, index(dc) >= cut.date)
data.2 <- data.2[,1:2]
R.2 <- as.matrix(colMeans(data.2)) + 1
Sig.2 <- cov(data.2)
t.2 <- HJ.bound(R.2,Sig.2,v.seq)
#plot(v.seq,v.seq * t.2, type = 'l')
plot(v.seq, v.seq * t, col = "red", type = 'l',
xlab = expression(bar(M)), ylab = expression(sigma(M)),
main = "Hansen-Jagannathan Bound", lty = 5,
xlim= c(0.95,1.05), ylim=c(0,5))
lines(v.seq,v.seq * t.2, type = 'l', lwd = 3)
df.hj <- data.frame(m.mean = v.seq, sig = v.seq * t)
df.hj.2 <- data.frame(m.mean = v.seq, sig = v.seq * t.2)
demo(tidyr)
demo(tidy)
demo(package = "tidyr")
dadmom
demo(dadmom)
dadmom
dadmom %>% gather(key, value, named:incm)
?gather
dadmom %>% gather(renco, anchovy, named:incm)
dadmom %>% gather(key, value, named:incm) %>%
separate(key, c("variable", "type"), -2)
dadmom %>% gather(key, value, named:incm)
dadmom %>% gather(key, value, named:incm) %>% separate(key, c("variable", "type"), -2)
demo(dadmom)
demo(so-17481212)
demo(17481212)
demo(s0-17481212)
demo(so-17481212)
cute.s.g
class(cute.s.g)
cute.s.g <- xts(s.g, order.by = index(c)[2:length(index(c))])
# package staging ---------------------------------------------------------
rm(list=ls())
require(data.table)
require(ggplot2)
require(quantmod)
require(magrittr)
require(knitr)
# data preparation --------------------------------------------------------
getSymbols(Symbols = "PCND", src = "FRED") #quarterly
getSymbols(Symbols = "GDPDEF", src = "FRED") #quarterly
getSymbols(Symbols = "CNP16OV", src = "FRED") # monthly
getSymbols(Symbols = "GS1", src = "FRED") #monthly t-rate
getSymbols(Symbols = "^GSPC", src = "yahoo", from =
"1952-08-01", to = "2016-12-31")
getSymbols(Symbols = "CNP16OV", src = "FRED")
c <- get("PCND") #starts at 1947
p <- get("GDPDEF") #starts at 1947
n <- get("CNP16OV") #starts at 1948
spp <- get("GSPC") %>% quarterlyReturn
r <- get("GS1") #starts at 1953
#let series all start with 1953
start.date <- as.Date("1953-01-01")
c <- c[index(c) >= start.date]
p <- p[index(p) >= start.date]
n <- n[index(n) >= start.date]
spp <- spp[index(spp) >= start.date - 10]
r <- r[index(r) >= start.date]
#real consumption
c <- c / p
#per capita c
#population unit: thousands
#consumption unit: billions
n <- n[index(n) %in% index(c)] #to quarterly
c <- c * 1e10 / (n * 1000)
cute.s.g <- xts(s.g, order.by = index(c)[2:length(index(c))])
cute.s <- xts(s.seq, order.by = index(c))
# package staging ---------------------------------------------------------
rm(list=ls())
require(data.table)
require(ggplot2)
require(quantmod)
require(magrittr)
require(knitr)
# data preparation --------------------------------------------------------
getSymbols(Symbols = "PCND", src = "FRED") #quarterly
getSymbols(Symbols = "GDPDEF", src = "FRED") #quarterly
getSymbols(Symbols = "CNP16OV", src = "FRED") # monthly
getSymbols(Symbols = "GS1", src = "FRED") #monthly t-rate
getSymbols(Symbols = "^GSPC", src = "yahoo", from =
"1952-08-01", to = "2016-12-31")
getSymbols(Symbols = "CNP16OV", src = "FRED")
c <- get("PCND") #starts at 1947
p <- get("GDPDEF") #starts at 1947
n <- get("CNP16OV") #starts at 1948
spp <- get("GSPC") %>% quarterlyReturn
r <- get("GS1") #starts at 1953
#let series all start with 1953
start.date <- as.Date("1953-01-01")
c <- c[index(c) >= start.date]
p <- p[index(p) >= start.date]
n <- n[index(n) >= start.date]
spp <- spp[index(spp) >= start.date - 10]
r <- r[index(r) >= start.date]
#real consumption
c <- c / p
#per capita c
#population unit: thousands
#consumption unit: billions
n <- n[index(n) %in% index(c)] #to quarterly
c <- c * 1e10 / (n * 1000)
plot(c, main = "real consumption per capita")
#consumption growth rate
dc <- coredata(c[2:length(c)]) / coredata(c[1:length(c) - 1]) - 1
dc <- xts(dc, order.by = index(c)[2:length(c)])
#Return to quarterly return
r <- r[index(r) %in% index(c)]
r <- r / 100 #convert to decimal
r <- r/4 #convert to quarterly return
sp <- copy(spp)
spp <- sp[2:(length(spp) - 1)]
index(spp) <- index(dc)
plot(index(spp),coredata(spp), col = "blue", type = 'l',
lty = 5, xlab = "Date", ylab = "")
lines(index(spp), coredata(dc), lwd = 2)
names(spp) <- "SP500"
names(dc) <- "PCCG"
names(r) <- "TBill"
data <- data.frame(sp = coredata(spp),
r = coredata(r),
dc = coredata(dc))
print("Mean Returns are(in percentage)")
kable(data.frame(lapply(data[,1:2] * 100,mean)))
cat("\n")
print("Standard Deviations are(in percentage)")
kable(data.frame(lapply(data[,1:2], sd)))
cat("\n")
print("Correlations are(in percentage)")
kable(cor(data))
## H-J Bound
data.r <- data[,1:2] + 1
R <- as.matrix(colMeans(data.r))
Sig <- cov(data.r)
HJ.bound <- function(R,Sig,v.seq){
b.seq <- rep(0,length(v.seq))
count <- 0
for (v in v.seq) {
count <- count + 1
b.seq[count] <- sqrt(t(1 - v * R) %*% solve(Sig) %*% (1 - v * R)) / v
}
return(b.seq)
}
v.seq <- seq(0.8,1.2,by = 0.0001)
t <- HJ.bound(R,Sig,v.seq)
#plot the HJ Bound
#plot(v.seq,v.seq * t, type = 'l')
#Use data after 2000
cut.date <- as.Date("2000-01-01")
data <- cbind(data,index(dc))
data.2 <- subset(data, index(dc) >= cut.date)
data.2 <- data.2[,1:2]
R.2 <- as.matrix(colMeans(data.2)) + 1
Sig.2 <- cov(data.2)
t.2 <- HJ.bound(R.2,Sig.2,v.seq)
#plot(v.seq,v.seq * t.2, type = 'l')
plot(v.seq, v.seq * t, col = "red", type = 'l',
xlab = expression(bar(M)), ylab = expression(sigma(M)),
main = "Hansen-Jagannathan Bound", lty = 5,
xlim= c(0.95,1.05), ylim=c(0,5))
lines(v.seq,v.seq * t.2, type = 'l', lwd = 3)
df.hj <- data.frame(m.mean = v.seq, sig = v.seq * t)
df.hj.2 <- data.frame(m.mean = v.seq, sig = v.seq * t.2)
dc.2 <- dc[index(dc) >= as.Date("2001-01-01")]
delta = 0.98
ccapm.m <- function(dc,delta,gamma){
m <- delta * dc^(-gamma)
temp <- numeric()
temp[1] <- mean(m)
temp[2] <- sd(m)
return(temp)
}
gamma.seq <- seq(1,40,by = 1)
mm.1 <- sapply(gamma.seq, ccapm.m, dc = dc + 1, delta = delta)
#this is the data frame for ccapm
df.1 <- data.frame(m.mean = mm.1[1,],
sig = mm.1[2,],
gamma = gamma.seq)
ggplot() + geom_line(data = df.hj, aes(x = m.mean, y = sig)) +
geom_text(data = df.1, aes(x = m.mean, y = sig, label = gamma), size = 3.75) +
xlim(0.96,1.025) + ylim(0,1.05) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
ggplot() + geom_line(data = df.hj.2, aes(x = m.mean, y = sig)) +
geom_text(data = df.1, aes(x = m.mean, y = sig, label = gamma)) +
xlim(0.95,1.05) + ylim(0,2.25) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
r.m <- coredata(spp) + 1
r.m.2 <- coredata(spp[index(spp) >= as.Date("2001-01-01")]) + 1
ez.m <- function(dc, delta, rho, alpha, r.m){
m <- (delta * dc^(rho + 1))^(alpha/rho) * (1/r.m)^(1 - alpha/rho)
temp <- numeric()
temp[1] <- mean(m)
temp[2] <- sd(m)
return(temp)
}
alpha.seq <- 1 - seq(1,30,by = 2)
rho.seq <- 1 - 1 / seq(0.2,2, by = 0.25)
ez.m.mean <- numeric()
ez.m.std <- numeric()
alpha.q <- numeric()
rho.q <- numeric()
count <- 0
for (alpha in alpha.seq) {
for (rho in rho.seq) {
count <- count + 1
temp <- ez.m(dc.2 + 1,delta, rho, alpha, r.m.2)
ez.m.mean[count] <- temp[1]
ez.m.std[count] <- temp[2]
alpha.q[count] <- alpha
rho.q[count] <- rho
}
}
df.2 <- data.frame(m.mean = ez.m.mean,
sig = ez.m.std,
alpha = alpha.q,
rho = rho.q)
df.2 <- subset(df.2, m.mean < 2 & sig < 12)
ggplot() + geom_line(data = df.hj.2, aes(x = m.mean, y = sig)) +
geom_point(data = df.2, aes(x = m.mean, y = sig), col = "blue") +
ylim(0,2.25) + xlim(0.95,1.05) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
q.2 <- copy(df.2)
q.2$hj <- HJ.bound(R.2,Sig.2,q.2$m.mean)
q.2$ok <- (q.2$sig > q.2$hj)
q.2 <- subset(q.2, ok == TRUE)
q.2 <- q.2[,3:4]
kable(q.2, row.names = FALSE, align = c('l','l'),
caption = "EZ-Paramter Values Consistent with Data")
delta = 0.9
mu <- mean(dc)
kappa <- sd(dc)
# mu <- mean(dc.2)
# kappa <- sd(1 + dc.2)
f <- function(s.bar, s.t){
if (log(s.t) < log(s.bar) + 1/2 * (1 - s.bar^2)) {
1/s.bar * sqrt(1 - 2 * (log(s.t) - log(s.bar))) - 1
}else {
0
}
}
phi.seq <- c(0.5,0.9,0.95)
gamma.seq <- seq(1, 10, by = 0.25)
cc <- coredata(c) + 1
cc.m.mean <- numeric()
cc.m.std <- numeric()
phi.q <- numeric()
gamma.q <- numeric()
count <- 0
for (phi in phi.seq) {
for (gamma in gamma.seq) {
count <- count + 1
s.bar <- kappa * sqrt(gamma/(1 - phi))
s.seq <- numeric()
s.seq[1] <- 1
for (t in 2:length(cc)) {
s.seq[t] <- exp((1 - phi) * log(s.bar) +
phi * log(s.seq[t - 1]) +
f(s.bar, s.seq[t - 1]) * (log(cc[t]) - log(cc[t - 1]) - mu))
}
s.g <- s.seq[2:length(s.seq)] / s.seq[1:length(s.seq) - 1]
temp.m <- delta * ( s.g * (coredata(dc) + 1) )^(-gamma)
cc.m.mean[count] <- mean(temp.m)
cc.m.std[count] <- sd(temp.m)
phi.q[count] <- phi
gamma.q[count] <- gamma
} #gamma
}#phi
cute.s <- xts(s.seq, order.by = index(c))
plot(cute.s[index(cute.s) >= as.Date("1960-01-01")], main = expression(S[t]))
cute.s.g <- xts(s.g, order.by = index(c)[2:length(index(c))])
plot(cute.s.g[index(cute.s.g) >= as.Date("1960-01-01")], main = expression(S[t]/S[t-1]))
df.3 <- data.frame(m.mean = cc.m.mean,
sig = cc.m.std,
phi = phi.q,
gamma = gamma.q)
df.3 <- subset(df.3, m.mean < 1.25 & sig < 12)
ggplot() + geom_line(data = df.hj
, aes(x = m.mean, y = sig)) +
geom_point(data = df.3, aes(x = m.mean, y = sig), col = "blue") +
ylim(0,2.25) + xlim(0.95,1.05) + xlab(expression(bar(M))) +
ylab(expression(sigma(M)))
import numpy as np
import numpy as np
###Momentum Trading Detector
require(quantmod)
require(xts)
require(data.table)
require(lubridate)
setwd("/Users/renco/GitHub/Renco_Quant_Trading")
start_date <- today() - 30
end_date <- today()
# Should we trade? --------------------------------------------------------
#Is market in distress?
getSymbols("000001.SS", from = start_date,
to = end_date)
sh <- dailyReturn(get("000001.SS"))
sh <- data.table(coredata(sh), index(sh))
names(sh) <- c("d.ret", "date")
sh <- sh[d.ret !=  0 ]
sh.ret <- prod(1 + head(tail(sh$d.ret,8),7))
if (sh.ret < 1) {
print("No Trading ")
}else{
print("Good to go")
}
print(tail(index(get("000001.SS")),1))
print(sh.ret)
# Momentum Strat ----------------------------------------------------------
stock_list <- load("All_list.RData")
stocks_code <- as.vector(as.matrix(get(stock_list))) #for looping to saving time
mom.df <- data.frame(matrix(rep(NA, 2 * length(stocks_code)), ncol = 2))
names(mom.df) <- c("symbol","cum.ret")
code_count <- 0
for (code in stocks_code) {
code_count <- code_count + 1
symbol <- "" ##Initiate
symbol <- paste(sprintf("%06d", code),
ifelse(code <= 600000, "SZ","SS"),
sep = ".") #SZ stocks has number smaller than 1000
#getSymbols(symbol,from=start_date) #Fecthing data
tryCatch({getSymbols(symbol,from = start_date,to = end_date)
#atr <- lag(ATR(get(symbol)))
#ajusted for split and dividends
#get(symbol) <- adjustOHLC(get(symbol),use.Adjusted=TRUE)
ret.ts <- dailyReturn(get(symbol))
ret.ts <- data.table(coredata(ret.ts),index(ret.ts))
names(ret.ts) <- c("d.ret","date")
ret.ts <- ret.ts[d.ret != 0] #take out daily not trading
if (dim(ret.ts)[1] < 7) {
removeSymbols(symbol) #house keeping
next
}
#last 7 days skippping the most recent day
temp.cum.ret <- prod(1 + head(tail(ret.ts$d.ret,8),7))
mom.df[code_count,"symbol"] <- symbol
mom.df[code_count,"cum.ret"] <- temp.cum.ret
removeSymbols(symbol)  #house keeping
},
warning = function(msg) {
print(paste("Caught warning message:", msg))
},
error = function(msg) {
print(paste("Caught fatal message:", msg))
return(NA)
}
) #tryCatch
} #for
mom.dt <- data.table(mom.df)
mom.dt <- mom.dt[order(-cum.ret)]
mom.dt <- mom.dt[is.na(cum.ret) == FALSE]
cat("Top 20 Winners:\n\n")
print(head(mom.dt,20))
port <- head(mom.dt, 20)
# optimal portfolio  ------------------------------------------------------
N = 5
exclude <- c()
port <- port[!symbol %in% exclude]
port
